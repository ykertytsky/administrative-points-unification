# administrative-points-unification
# Звіт за проєктом “Об’єднання в адміністративні одиниці”

## Загальний опис проблеми
Метою проєкту є розробка алгоритму для оптимального поділу території на адміністративні одиниці. Основна ідея полягає в тому, щоб групувати населені пункти, які знаходяться близько один до одного, у спільні кластери.  
Виконання завдання вимагає знань з теорії графів, кластеризації та модулярності, а також роботи із бібліотеками Python для створення DataFrame і візуалізації проєкту.

## Наше розв’язання задачі
Виконання задачі ми розпочали з створення DataSet. Програма отримує вхідні дані у вигляді csv таблиці, яка містить інформацію про міста і відстань між ними. Файл репрезентує граф, де населені пункти – це вузли графу, а дороги між містами – ребра.  

Для роботи з DataSet і візуального відображення кластерів ми імпортуємо наступні бібліотеки:
- **networkx (nx):** бібліотека для створення, маніпулювання та аналізу графів і мереж.
- **numpy (np):** бібліотека для роботи з масивами та виконання числових обчислень.
- **pandas (pd):** бібліотека для роботи з таблицями та аналізу даних у форматі DataFrame.
- **matplotlib.pyplot (plt):** бібліотека для створення візуалізацій.

Після імпорту необхідних бібліотек, переходимо до розробки алгоритмів, які розбиватимуть міста на адміністративні одиниці.

## Основні алгоритми

### K-Means Algorithm
Для розподілу міст на адміністративні одиниці (кластери) ми використали алгоритм K-Means. Він спрямований на поділ об'єктів на k кластерів, щоб мінімізувати суму квадратів відстаней між об'єктами та їх центроїдами.  

Центр групи є середнім містом у кластері, і його положення обчислюється на основі координат усіх міст у цій групі. Алгоритм починає роботу з вибору кількох випадкових точок, які слугують початковими центрами кластерів.  

Далі кожне місто приєднується до того центру, який знаходиться до нього найближче. Після цього центри кластерів оновлюються: вони зміщуються до середини міст, які до них належать. Цей процес повторюється доти, поки центри не перестануть змінювати своє положення або не буде досягнуто заданої кількості повторень.  

Такий підхід добре працює для рівномірно розподілених даних, але у випадках, коли міста зібрані нерівномірно, алгоритм може створювати кластери різного розміру, що є його основним недоліком. З самого початку ми використовували алгоритм Уоршала в реалізації цього алгоритму, однак врахувавши те, що не обов’язково всі міста є пов’язаними між собою дорогами, ми змінили наш підхід.

### Balanced K-Means
Саме тому ми замінили K-Means на його більш оптимальну версію: Balanced K-Means.  

Balanced K-Means вирішує проблему нерівномірності кластерів, додаючи до процесу обмеження на кількість об'єктів у кожному кластері. Алгоритм зберігає загальні принципи роботи K-Means, але під час призначення об'єктів до кластерів перевіряє, чи не перевищує кластер свого дозволеного розміру.  

**balanced_kmeans(graph, k)**  
Виконує кластеризацію вузлів графа на задану кількість кластерів k із використанням збалансованого підходу. Алгоритм починається з випадкової ініціалізації початкових центроїдів кластерів.  

Для кожного вузла графа обчислюється відстань до кожного з центроїдів за допомогою функції `nx.shortest_path_length`, яка враховує вагу ребер. Вузол призначається до найближчого кластеру, однак із врахуванням обмеження на максимальну кількість вузлів у кожному кластері.  

Після формування кластерів обчислюються нові центроїди. Кожен новий центроїд визначається як вузол у підграфі кластеру, сумарна відстань від якого до інших вузлів є мінімальною. Процес повторюється ітеративно, доки центроїди не перестануть змінюватися або не буде досягнуто максимального числа ітерацій.  

**visualize_clusters(graph, clusters, title)**  
Візуалізує результати кластеризації. Для розташування вузлів на площині використовується алгоритм розкладки `nx.spring_layout`. Вузли кластерів малюються різними кольорами, а для кожного кластеру додається підпис у легенді графіку.
...

### Louvain Algorithm
Для знаходження модульної структури графу ми скористались Louvain Algorithm, який оптимізує модульність — міру якості розбиття графу (щільність внутрішніх зв'язків).  

Louvain починає з того, що кожен вузол вважається окремою спільнотою.  
1. **Локальна оптимізація**: Ітеративно переміщує вузли між сусідніми спільнотами, намагаючись максимізувати приріст модульності.  
2. **Агрегація**: Граф агрегується — спільноти стають новими вузлами, і процес повторюється.  
3. Ці кроки тривають, поки модульність не перестане зростати.  

Алгоритм повертає словник, де кожному вузлу призначено його спільноту. Також візуалізація допомагає оцінити якість кластеризації.

---

## Реалізовані функції

- **read_distance_data**  
  Завантажує дані з CSV-файлу, що містить інформацію про відстані між містами. Перевіряє наявність необхідних стовпців ("Point1", "Point2", "distance") і стандартизує їх назви. У разі успіху повертає таблицю.  

- **create_graph_from_csv**  
  Побудова графа на основі даних із таблиці. Вузли представляють міста, ребра — дороги між ними, а вага ребра дорівнює відстані.  

- **create_graph_dict**  
  Переводить граф у формат словника, де кожне місто стає ключем, а його сусіди — значеннями.  

- **calculate_total_weight**  
  Обчислює загальну довжину всіх доріг у графі.  

- **calculate_node_degree**  
  Рахує "вагу" для кожного міста (суму відстаней до всіх сусідів).  

- **modularity_gain**  
  Визначає, наскільки покращиться зв’язність, якщо перенести місто до іншої групи.  

- **louvain_community_detection**  
  Основний алгоритм для поділу графа на групи. Кожне місто початково є окремою групою. Алгоритм ітеративно перевіряє, чи покращиться модульність, якщо місто приєднати до іншої групи.  

- **louvain_visualize_communities**  
  Створює візуалізацію графа з поділом на групи, позначаючи міста кольорами відповідних кластерів.  

- **communities_to_dict**  
  Формує підсумковий список груп у вигляді словника, де кожна група має унікальний номер.

---

## Підсумки

### Вхідні дані:
- Граф, де вузли — це населені пункти, а ребра — дороги між ними.  
- Ваги ребер — це відстані між пунктами.

### Ключове завдання:
- Населені пункти, які знаходяться близько один до одного (з урахуванням ваг ребер), повинні належати до одного кластеру.

### Загальний принцип роботи алгоритмів:
- **K-Means**  
  1. Ініціалізація: вибір випадкових міст як початкових центрів.  
  2. Розподіл: кожне місто приєднується до найближчого центроїда.  
  3. Оновлення центроїдів: обчислення нового центру для кожного кластеру.  
  4. Завершення: стабілізація або досягнення максимального числа ітерацій.  

- **Louvain**  
  1. Локальна оптимізація: міста об’єднуються в спільні адміністративні центри для зменшення розривів.  
  2. Об’єднання: групи стають "супермістами", формуючи новий граф.  
  3. Завершення: процес повторюється, поки нові округи не покращують розподіл.

---

## Розподіл роботи між учасниками

- **Створення початкового датасету**: Кертуцький Ярема, Дзюба Оксана, Мельник Владислава.  
- **Розробка основних алгоритмів**:  
  - Костюк Остап (K-Means, Balanced K-Means).  
  - Кертуцький Ярема (csv-parser).  
  - Печенненко Ярина (Louvain).  
- **Написання звіту та створення презентації**: Мельник Владислава, Дзюба Оксана.

