### louvian algorithm

**eate_graph_dicth**
Перетворює граф на словник суміжносіті, зберігаючи ваги ребер (якщо ваги немає за замовчуванням ставить 1).
`приклад`
    'A': {'B': 1, 'C': 2},
    'B': {'A': 1, 'C': 1},
    'C': {'A': 2, 'B': 1}

**calculate_total_weigh**
Обчислює загальну вагу графа, враховує, що в неорієнтованому графі всі ребера рахуються двічі, тому суму ділить на 2.

**calculate_node_degree**
Обчислює зважений степінь (суму ваг усіх ребер, що з’єднують вершину з іншими).

**modularity_gain**

community_internal_weight / total_weight - (community_total_weight * node_degree) / (2 * total_weight^2)

1) Частка ваги зв’язків між вершиною і спільнотою від загальної ваги графа.
2) Частка впливу степеня вершини на загальну вагу спільноти.
Зміна модульності є різницею між цими двома значеннями:
Позитивна зміна означає покращення модульності.
Негативна — погіршення.

`приклад`
Граф:
Вершини: A, B, C, D.
Ребра:
A -> B (вага 3),
A -> C (вага 2),
B -> C (вага 4),
B -> D (вага 1).

Вхідні дані:
graph_dict = {'A': {'B': 3, 'C': 2}, 'B': {'A': 3, 'C': 4, 'D': 1}, 'C': {'A': 2, 'B': 4}, 'D': {'B': 1}}
total_weight = 10 (сума всіх ваг, поділена на 2).
node = 'A'.
community = 2 (умовна нова спільнота).
node_communities = {1: {'B', 'C'}, 2: {'D'}}.
Розрахунок:

node_degree = 3 + 2 = 5.
community_internal_weight = 0 (ребра між A і D немає).
community_total_weight = 1 (ребро D -> B має вагу 1).
_ΔQ = (0 / 10) - ((1 * 5) / (2 * 10^2)) = -0.0025_

Результат:
Зміна модульності негативна, тому переміщення A в нову спільноту недоцільне.


**louvain_community_detection**

За алгоритмом лувіана:
1. спочатку кожна вершина знаходиться у власній спільноті спільноті (одна вершина -- одна спільнота).
2. Спершу модулярність рахується для початкових спільнот, а далі алгоритм починає обʼєднувати вершини, намагаючись підвищити модулярність.
3. рандомно обираючи вершину переміщує її в інші спільноти враховуючи знак модулярності (має бути додатнім), якщо ні, то залишає в своїй спільноті.

while improved:
    improved = False
_Головний цикл триває, доки знаходяться зміни, що покращують модульність графа._

Після завершення повертається список спільнот, наприклад: 
[{'A', 'B', 'C'}, {'D', 'E'}, {'F'}]